/**
 * Validates that index.html contains all DOM elements required by app.js.
 *
 * Run with: node src/runtimes/tauri/src/index.test.js
 *
 * This catches regressions where an element id is renamed in the HTML
 * but not in the JS (or vice-versa).
 */

const { describe, it } = require("node:test");
const assert = require("node:assert/strict");
const fs = require("node:fs");
const path = require("node:path");

const htmlPath = path.join(__dirname, "index.html");
const html = fs.readFileSync(htmlPath, "utf-8");

// IDs that app.js references via getElementById
const REQUIRED_IDS = [
  "play-btn",
  "pause-btn",
  "stop-btn",
  "next-btn",
  "prev-btn",
  "volume-slider",
  "volume-value",
  "search-btn",
  "search-input",
  "add-folder-btn",
  "scan-library-btn",
  "settings-btn",
  "clear-playlist-btn",
  "settings-btn",
  "current-song-title",
  "current-song-artist",
  "progress-fill",
  "time-current",
  "time-total",
  "playlist",
  "results-list",
  "status-message",
  "backend-status",
  "settings-modal",
  "settings-close-btn",
  "settings-cancel-btn",
  "settings-save-btn",
  "setting-fullscreen",
  "setting-zoom",
];

describe("index.html structure", () => {
  for (const id of REQUIRED_IDS) {
    it(`contains element with id="${id}"`, () => {
      const pattern = new RegExp(`id=["']${id}["']`);
      assert.match(html, pattern, `Missing element with id="${id}" in index.html`);
    });
  }

  it("loads styles.css", () => {
    assert.ok(html.includes("styles.css"), "Should include styles.css link");
  });

  it("loads app.js", () => {
    assert.ok(html.includes("app.js"), "Should include app.js script");
  });

  it("has a proper DOCTYPE", () => {
    assert.ok(
      html.trimStart().startsWith("<!DOCTYPE html>"),
      "Should start with DOCTYPE"
    );
  });

  it("sets UTF-8 charset", () => {
    assert.ok(
      html.includes('charset="UTF-8"') || html.includes("charset=UTF-8"),
      "Should declare UTF-8 charset"
    );
  });

  it("has a viewport meta tag", () => {
    assert.ok(html.includes("viewport"), "Should have viewport meta tag");
  });

  it("has a title element", () => {
    assert.match(html, /<title>.*<\/title>/s, "Should have a <title> element");
  });

  it("contains the app root container", () => {
    assert.match(html, /id=["']app["']/, 'Should have root div#app');
  });
});

describe("CSS classes used by app.js exist in HTML", () => {
  const requiredClasses = [
    "song-item",
    "song-item-title",
    "song-item-artist",
    "no-results",
    "progress-fill",
  ];

  for (const cls of requiredClasses) {
    it(`HTML or CSS references class "${cls}"`, () => {
      // These classes are rendered dynamically by JS, but the progress-fill
      // class should exist in the static HTML as well
      if (cls === "progress-fill") {
        assert.ok(
          html.includes(cls),
          `Class "${cls}" should appear in index.html`
        );
      }
      // Other classes are generated by innerHTML, so just verify the
      // constant string appears in app.js
      const appJs = fs.readFileSync(
        path.join(__dirname, "app.js"),
        "utf-8"
      );
      assert.ok(
        appJs.includes(cls),
        `Class "${cls}" should appear in app.js`
      );
    });
  }
});

describe("Accessibility basics", () => {
  it("has lang attribute on html element", () => {
    assert.match(
      html,
      /<html\s+[^>]*lang=/,
      'The <html> element should have a lang attribute'
    );
  });

  it("input elements have associated labels or placeholders", () => {
    // At minimum, inputs should have placeholders for a11y
    const inputs = html.match(/<input[^>]*>/g) || [];
    for (const input of inputs) {
      const hasPlaceholder = input.includes("placeholder=");
      const hasAriaLabel = input.includes("aria-label=");
      const hasId = input.includes("id=");
      assert.ok(
        hasPlaceholder || hasAriaLabel || hasId,
        `Input should have placeholder, aria-label, or id: ${input.slice(0, 60)}`
      );
    }
  });

  it("buttons have visible text content", () => {
    // Regex to find buttons with content between tags
    const buttons = html.match(/<button[^>]*>([^<]*)<\/button>/g) || [];
    for (const btn of buttons) {
      const content = btn.replace(/<[^>]+>/g, "").trim();
      assert.ok(
        content.length > 0,
        `Button should have text content: ${btn.slice(0, 60)}`
      );
    }
  });
});
